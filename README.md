# Work-CLI
Manage your shell srcipt
> Well...Just a little tool,i don't expect there to be users
---

## 核心优势
- **集中管理**：配置文件统一存放于 `~/.config/work/`（用户配置）和 `/etc/work/`（公共配置）。
- **优先级机制**：公共配置优先级高于用户配置，冲突时公共配置生效。
- **安全性**：强制要求配置文件包含 `main` 函数和条件判断，确保命令在安全上下文中执行。
- **灵活性**：支持任何可编程任务，如新建项目、构建、测试、部署等。

---

## 安装与配置路径
Work 的配置文件分为两层：
1. **公共配置**：存放于系统级目录 `/etc/work/`（需管理员权限创建或修改）。
2. **用户配置**：存放于用户目录 `~/.config/work/`。

**优先级规则**：
- 当公共配置和用户配置中存在同名的 `.work` 文件时，公共配置的版本始终优先执行。
- 用户配置可作为公共配置的补充或扩展，但无法覆盖公共配置的逻辑。

---

## 配置文件规范

### 文件结构
1. **第一行**：必须包含 `INFO` 变量，格式为：
   ```bash
   INFO="命令名:版本@作者"
   ```
2. **main 函数**：定义核心逻辑，接收所有参数。
3. **条件判断**：确保命令在正确环境中执行（如路径检查）。

---

## 配置示例
### Rust/Python 项目或Work脚本创建
```bash

INFO="new:1.0@work"

if [ $# -eq 0 ]; then
    echo "请提供文件名参数"
    exit 1
fi

main_work() {
    if ! cp ./template.work "./$1.work"; then
        echo "复制模板文件失败"
        exit 1
    fi
}

main_cargo() {
    cargo new "$1" || { echo "创建Rust项目失败"; exit 1; }
}

main_python() {
    echo "print('Hello,world!')" > "./$1.py" || { echo "创建Python文件失败"; exit 1; }
}

if [[ $PWD =~ .*work ]]; then
    main_work "$@"
elif [[ $PWD =~ .*rust ]]; then
    main_cargo "$@"
elif [[ $PWD =~ .*python ]]; then
    main_python "$@"
else
    echo "当前目录路径不支持初始化操作"
    exit 1
fi

---

## 使用方法
```bash
work <命令> [参数]
```

### 参数映射
- `<命令>`：首先匹配 `/etc/work/<命令>.work`，若不存在则匹配 `~/.config/work/<命令>.work`。
- `[参数]`：传递给配置文件的 `main` 函数。

---

## 功能扩展

### 公共配置的典型用途
1. **系统级安全策略**：例如强制要求在特定路径下执行敏感操作。
2. **组织规范**：团队可统一配置代码规范检查、构建流程等。
3. **全局工具链**：管理跨用户的通用工具（如 `git`、`docker` 快捷命令）。

---

## 为什么选择 Work？
1. **分层管理**：公共配置与用户配置分离，兼顾系统规范与个性化需求。
2. **安全性增强**：公共配置可强制执行安全策略（如路径限制、权限检查）。
3. **团队协作友好**：系统管理员可统一维护关键配置，用户可自由扩展功能。


## 待实现功能
1. **不安全的脚本支持**
2. **命令行的脚本管理器**
3. **随时随地的脚本运行**

---

## 结语
Work 的公共配置功能进一步提升了工具的灵活性和安全性。通过分层配置机制，既保证了系统级操作的统一性，又允许用户灵活定制个性化工作流。无论是个人开发者还是团队协作，Work 都能提供高效且安全的解决方案。lol，this readme make by deepseek.
